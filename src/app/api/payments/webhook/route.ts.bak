import { NextRequest, NextResponse } from 'next/server';
import { PaymentService } from '@/lib/payment-service';
import { DatabaseService } from '@/lib/database';
import { EmailService } from '@/lib/email-service';

export async function POST(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const provider = url.searchParams.get('provider') || 'razorpay';

    switch (provider) {
      case 'razorpay':
        return await handleRazorpayWebhook(request);
      case 'stripe':
        return await handleStripeWebhook(request);
      case 'paypal':
        return await handlePaypalWebhook(request);
      default:
        return NextResponse.json(
          { success: false, error: 'Unsupported payment provider' },
          { status: 400 }
        );
    }
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Webhook processing failed' },
      { status: 500 }
    );
  }
}

async function handleRazorpayWebhook(request: NextRequest) {
  try {
    const payload = await request.json();
    const signature = request.headers.get('x-razorpay-signature');

    if (!signature) {
      return NextResponse.json(
        { success: false, error: 'Missing signature' },
        { status: 400 }
      );
    }

    // Verify webhook signature
    const isValid = await PaymentService.handleRazorpayWebhook(payload, signature);
    if (!isValid) {
      return NextResponse.json(
        { success: false, error: 'Invalid signature' },
        { status: 401 }
      );
    }

    const { event, payload: razorpayPayload } = payload;
    const payment = razorpayPayload.payment.entity;

    switch (event) {
      case 'payment.captured':
        await handleSuccessfulPayment(payment);
        break;
      
      case 'payment.failed':
        await handleFailedPayment(payment);
        break;
      
      case 'payment.authorized':
        await handleAuthorizedPayment(payment);
        break;
      
      case 'refund.processed':
        await handleRefundProcessed(payment);
        break;
      
      default:
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Webhook handling failed' },
      { status: 500 }
    );
  }
}

async function handleStripeWebhook(request: NextRequest) {
  try {
    const payload = await request.text();
    const signature = request.headers.get('stripe-signature');

    if (!signature) {
      return NextResponse.json(
        { success: false, error: 'Missing signature' },
        { status: 400 }
      );
    }

    // Verify webhook signature
    const isValid = await PaymentService.handleStripeWebhook(payload, signature);
    if (!isValid) {
      return NextResponse.json(
        { success: false, error: 'Invalid signature' },
        { status: 401 }
      );
    }

    const event = JSON.parse(payload);

    switch (event.type) {
      case 'payment_intent.succeeded':
        await handleSuccessfulPayment(event.data.object);
        break;
      
      case 'payment_intent.payment_failed':
        await handleFailedPayment(event.data.object);
        break;
      
      case 'payment_intent.canceled':
        await handleCanceledPayment(event.data.object);
        break;
      
      case 'charge.dispute.created':
        await handleDisputeCreated(event.data.object);
        break;
      
      default:
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Webhook handling failed' },
      { status: 500 }
    );
  }
}

async function handlePaypalWebhook(request: NextRequest) {
  try {
    const payload = await request.json();

    // Verify webhook signature
    const isValid = await PaymentService.handlePayPalWebhook(payload);
    if (!isValid) {
      return NextResponse.json(
        { success: false, error: 'Invalid signature' },
        { status: 401 }
      );
    }

    const eventType = payload.webhook_event.event_type;

    switch (eventType) {
      case 'PAYMENT.CAPTURE.COMPLETED':
        await handleSuccessfulPayment(payload.webhook_event.resource);
        break;
      
      case 'PAYMENT.CAPTURE.DENIED':
        await handleFailedPayment(payload.webhook_event.resource);
        break;
      
      case 'PAYMENT.CAPTURE.REFUNDED':
        await handleRefundProcessed(payload.webhook_event.resource);
        break;
      
      default:
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Webhook handling failed' },
      { status: 500 }
    );
  }
}

// Helper functions for handling different payment states
async function handleSuccessfulPayment(payment: any) {
  try {

    // Get ticket details from payment metadata
    const paymentId = payment.id || payment.payment_intent || payment.capture_id;
    
    // Update ticket status to confirmed
    const tickets = await DatabaseService.getTickets({ status: 'pending' });
    const ticket = tickets.find(t => t.payment_id === paymentId);
    
    if (ticket) {
      await DatabaseService.updateTicket(ticket.id, { 
        status: 'confirmed',
        payment_id: paymentId
      });

      // Update event available tickets
      const event = await DatabaseService.getEventById(ticket.event_id);
      if (event) {
        await DatabaseService.updateEvent(event.id, {
          available_tickets: Math.max(0, event.available_tickets - ticket.quantity)
        });
      }

      // Send confirmation email
      const user = await DatabaseService.getUserById(ticket.user_id);
      if (user && event) {
        await EmailService.sendTicketConfirmation(user.email, {
          userName: user.full_name,
          eventTitle: event.title,
          eventDate: event.date,
          eventLocation: event.location,
          ticketType: ticket.type,
          quantity: ticket.quantity,
          totalAmount: ticket.total_price,
          ticketId: ticket.id
        });
      }

    }
  } catch (error) {
  }
}

async function handleFailedPayment(payment: any) {
  try {

    const paymentId = payment.id || payment.payment_intent || payment.capture_id;
    
    // Update ticket status to cancelled
    const tickets = await DatabaseService.getTickets({ status: 'pending' });
    const ticket = tickets.find(t => t.payment_id === paymentId);
    
    if (ticket) {
      await DatabaseService.updateTicket(ticket.id, { 
        status: 'cancelled',
        payment_id: paymentId
      });

    }
  } catch (error) {
  }
}

async function handleAuthorizedPayment(payment: any) {
  try {

    // Update ticket status to authorized (for manual capture)
    const paymentId = payment.id;
    const tickets = await DatabaseService.getTickets({ status: 'pending' });
    const ticket = tickets.find(t => t.payment_id === paymentId);
    
    if (ticket) {
      await DatabaseService.updateTicket(ticket.id, { 
        status: 'authorized',
        payment_id: paymentId
      });

    }
  } catch (error) {
  }
}

async function handleCanceledPayment(payment: any) {
  try {

    const paymentId = payment.id;
    const tickets = await DatabaseService.getTickets({ status: 'pending' });
    const ticket = tickets.find(t => t.payment_id === paymentId);
    
    if (ticket) {
      await DatabaseService.updateTicket(ticket.id, { 
        status: 'cancelled',
        payment_id: paymentId
      });

    }
  } catch (error) {
  }
}

async function handleRefundProcessed(refund: any) {
  try {

    const originalPaymentId = refund.payment || refund.payment_intent;
    
    // Find and update ticket to refunded status
    const tickets = await DatabaseService.getTickets({ status: 'confirmed' });
    const ticket = tickets.find(t => t.payment_id === originalPaymentId);
    
    if (ticket) {
      await DatabaseService.updateTicket(ticket.id, { 
        status: 'refunded',
        refund_id: refund.id
      });

      // Restore event capacity
      const event = await DatabaseService.getEventById(ticket.event_id);
      if (event) {
        await DatabaseService.updateEvent(event.id, {
          available_tickets: event.available_tickets + ticket.quantity
        });
      }

      // Send refund confirmation email
      const user = await DatabaseService.getUserById(ticket.user_id);
      if (user && event) {
        await EmailService.sendEmail({
          to: user.email,
          subject: `Refund Processed - ${event.title}`,
          html: `
            <h2>Refund Confirmation</h2>
            <p>Hi ${user.full_name},</p>
            <p>Your refund for the event "${event.title}" has been processed successfully.</p>
            <p><strong>Refund Amount:</strong> â‚¹${ticket.total_price}</p>
            <p><strong>Refund ID:</strong> ${refund.id}</p>
            <p>The refund should appear in your account within 3-5 business days.</p>
            <p>Thank you for your understanding.</p>
          `
        });
      }

    }
  } catch (error) {
  }
}

async function handleDisputeCreated(dispute: any) {
  try {

    const paymentId = dispute.payment;
    const tickets = await DatabaseService.getTickets({ status: 'confirmed' });
    const ticket = tickets.find(t => t.payment_id === paymentId);
    
    if (ticket) {
      // Update ticket status to under dispute
      await DatabaseService.updateTicket(ticket.id, { 
        status: 'disputed',
        dispute_id: dispute.id
      });

      // Notify admin about the dispute
    }
  } catch (error) {
  }
}

// Webhook validation endpoint
export async function GET(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const provider = url.searchParams.get('provider');
    const signature = url.searchParams.get('signature');

    if (!provider || !signature) {
      return NextResponse.json(
        { success: false, error: 'Missing provider or signature' },
        { status: 400 }
      );
    }

    // This endpoint can be used to verify webhook configurations
    return NextResponse.json({
      success: true,
      data: {
        provider,
        signature_valid: true,
        endpoint_active: true,
        message: 'Webhook endpoint is active and ready to receive events'
      }
    });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Validation failed' },
      { status: 500 }
    );
  }
}